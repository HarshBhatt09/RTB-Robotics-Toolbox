# -*- coding: utf-8 -*-
"""RTB_Kinematics_Calculations_Panda.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xhtAW6PLBLxQhj18xatVRvxmqzaxzhR9
"""

!pip3 install roboticstoolbox-python

import math
from spatialmath.base import *
from spatialmath import SE3
import spatialmath.base.symbolic as sym
import numpy as np

import roboticstoolbox as rtb

panda = rtb.models.URDF.Panda()
print(panda)
T = panda.fkine(panda.qz, end='panda_hand')
print(T)

point = SE3(0.6, -0.5, 0.0)
point_sol = panda.ikine_LM(point)
print("\nInverse Kinematics Solution :\n" ,point_sol)

## Creating Robotic arm through defining links and Serial Linkage
Link_1=rtb.DHLink(0.5, math.pi/2, 0, 0)
Link_2=rtb.DHLink(0,    0,   0, 0.4)
Link_3=rtb.DHLink(0,    0,   0, 0.4)
h2_panda_robot= rtb.DHRobot([Link_1 ,Link_2,Link_3])
h2_panda_robot

##Forward Kinematics

q1=50
q2=30
q3=0

T=h2_panda_robot.fkine([math.radians(q1),math.radians(q2),math.radians(q3)])

print("Transformation Matrix :\n",T)

# Selection a point to get inverse kinematics solution as angles
print("point-> x: %2.2f ,y: %2.2f ,z: %2.2f" %(1.5,2.5,2.3) )
point = SE3( 0.4453 , 0.5307 , 0.9  )
point_sol = h2_panda_robot.ikine_LM(point)
print(point_sol)

L = sym.symbol('l_1:4') # Symbolics for links
print("symblic Links : ",L)
Link_1=rtb.DHLink(L[0], math.pi/2, 0, 0)
Link_2=rtb.DHLink(0,    0,   0, L[1])
Link_3=rtb.DHLink(0,    0,   0, L[2])
Kaka_robot_symbolic= rtb.DHRobot([Link_1 ,Link_2,Link_3])

Q= sym.symbol('q1:4')   # Symbolics for rotations angles
print("symblic Angles : ",Q)

point = SE3(0.6, -0.5, 0.0)
# point_sol = puma.ikine_LM(point)
T_symbolic=Kaka_robot_symbolic.fkine(Q)
T_symbolic

Ts_symbolic = T_symbolic.simplify()
M = np.matrix(Ts_symbolic.A)
M

M[:3,3] # extracting translation part

T=Kaka_robot.fkine([40,30,10])  # NON symbolic
T

import roboticstoolbox as rtb
robot = rtb.models.DH.Panda()
print(robot)
T = robot.fkine(robot.qz)  # forward kinematics
print(T)

from spatialmath import SE3

T = SE3(0.7, 0.2, 0.1) * SE3.OA([0, 1, 0], [0, 0, -1])
sol = robot.ikine_LM(T)         # solve IK
print(sol)
q_pickup = sol.q
print(robot.fkine(q_pickup))

from math import pi

theta = np.array([0., 0., -0.25 * pi, 0., 0., 0.])
f = robot.forward(theta)

!pip3 install Swift

print("-------forward-------")
print("end frame t_4_4:")
print(f.t_4_4)
print("end frame xyz:")
print(f.t_3_1.reshape([3, ]))
print("end frame abc:")
print(f.euler_3)
print("end frame rotational matrix:")
print(f.r_3_3)
print("end frame quaternion:")
print(f.q_4)
print("end frame angle-axis:")
print(f.r_3)

robot.show()

xyz = np.array([[0.28127], [0.], [1.13182]])
abc = np.array([0.5 * pi, 0., pi])
end = Frame.from_euler_3(abc, xyz)
robot.inverse(end)
print("inverse is successful: {0}".format(robot.is_reachable_inverse))
print("axis values: \n{0}".format(robot.axis_values))
robot.show()

print("inverse is successful: {0}".format(robot.is_reachable_inverse))
print("axis values: \n{0}".format(robot.axis_values))
robot.show()





